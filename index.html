<!--
  Meal Prep Chat Application
  ==========================

  A browser-based chat application for managing meal preparation, recipes,
  meal planning, and inventory tracking. Users interact with an LLM through
  a chat interface to store recipes, plan meals, track batches, and query
  their meal prep data using natural language.

  HOW TO USE:
  1. Open this file in a modern browser (Chrome, Firefox, Safari, Edge)
  2. Configure your API provider, model name, and API key in the settings panel
  3. Start chatting! Ask the assistant to create recipes, plan meals, track
     meal prep sessions, and query your data.

  CONFIGURATION:
  - API Base URL: The base URL for your LLM provider's API
    - OpenAI: https://api.openai.com/v1
    - Anthropic: https://api.anthropic.com/v1
    - Other OpenAI-compatible providers: use their respective base URLs
  - Model: The model name to use (e.g., gpt-5-2, claude-sonnet-4-5-20250929)
  - API Key: Your API key for the selected provider

  EXAMPLE QUERIES:
  - "Add a recipe for chicken curry with rice"
  - "Plan next week's meals"
  - "Record a meal prep session for today"
  - "How many servings of pasta do I have left?"
  - "Which batches are about to expire?"
  - "What recipes use chicken?"
  - "Show me all my recipes"

  TROUBLESHOOTING:
  - If the database seems corrupted, click "Reset Database" in the settings
  - If API calls fail, verify your API key and base URL
  - Data is stored in localStorage; clearing browser data will erase it
  - The database is limited to ~5MB due to localStorage constraints
-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600&display=swap" rel="stylesheet">
<title>Meal Prep Chat</title>
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'IBM Plex Mono', 'Courier New', Courier, monospace;
  background: #0a0a0a;
  color: #d4d4d4;
  height: 100vh;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

#config-panel {
  background: #1a1a1a;
  border-bottom: 1px solid #333;
  padding: 8px 16px;
  display: flex;
  align-items: center;
  gap: 12px;
  flex-wrap: wrap;
  font-size: 13px;
}

#config-panel label {
  color: #888;
  white-space: nowrap;
}

#config-panel input, #config-panel select {
  background: #0a0a0a;
  border: 1px solid #333;
  color: #d4d4d4;
  font-family: 'IBM Plex Mono', 'Courier New', Courier, monospace;
  font-size: 13px;
  padding: 4px 8px;
  outline: none;
  border-radius: 6px;
}

#config-panel input:focus {
  border-color: #666;
}

#api-base-url { width: 260px; }
#model-name { width: 180px; }
#api-key { width: 200px; }

#config-panel button {
  background: #333;
  border: 1px solid #555;
  color: #d4d4d4;
  font-family: 'IBM Plex Mono', 'Courier New', Courier, monospace;
  font-size: 12px;
  padding: 4px 10px;
  cursor: pointer;
  border-radius: 6px;
}

#config-panel button:hover {
  background: #444;
}

#config-panel .config-group {
  display: flex;
  align-items: center;
  gap: 4px;
}

#config-toggle {
  background: none;
  border: 1px solid #333;
  color: #888;
  font-family: 'IBM Plex Mono', 'Courier New', Courier, monospace;
  font-size: 12px;
  padding: 2px 8px;
  cursor: pointer;
  margin-left: auto;
  border-radius: 6px;
}

#config-toggle:hover { color: #d4d4d4; }

#chat-container {
  flex: 1;
  overflow-y: auto;
  padding: 16px;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.message {
  max-width: 90%;
  padding: 8px 12px;
  line-height: 1.5;
  white-space: pre-wrap;
  word-wrap: break-word;
  font-size: 14px;
  border-radius: 8px;
}

.message-user {
  align-self: flex-end;
  color: #7fdbca;
  background: #0f1f1c;
}

.message-user::before {
  content: '> ';
  color: #555;
}

.message-assistant {
  align-self: flex-start;
  color: #c5c8c6;
  background: #161616;
}

.message-system {
  align-self: center;
  color: #666;
  font-size: 12px;
  font-style: italic;
}

.message-error {
  align-self: center;
  color: #cc6666;
  font-size: 13px;
}

.sql-result {
  background: #111;
  border: 1px solid #2a2a2a;
  padding: 6px 10px;
  margin-top: 6px;
  font-size: 12px;
  color: #999;
  max-height: 200px;
  overflow-y: auto;
  border-radius: 6px;
}

#input-area {
  border-top: 1px solid #333;
  padding: 12px 16px;
  display: flex;
  gap: 8px;
  background: #111;
}

#user-input {
  flex: 1;
  background: #0a0a0a;
  border: 1px solid #333;
  color: #d4d4d4;
  font-family: 'IBM Plex Mono', 'Courier New', Courier, monospace;
  font-size: 14px;
  padding: 8px 12px;
  outline: none;
  resize: none;
  min-height: 20px;
  max-height: 120px;
  border-radius: 8px;
  overflow-y: auto;
  scrollbar-width: thin;
  scrollbar-color: #444 #222;
}

#user-input::-webkit-scrollbar {
  width: 6px;
}

#user-input::-webkit-scrollbar-track {
  background: transparent;
}

#user-input::-webkit-scrollbar-thumb {
  background: #444;
  border-radius: 3px;
}

#user-input::-webkit-scrollbar-thumb:hover {
  background: #555;
}

#user-input:focus {
  border-color: #666;
}

#send-btn {
  background: #333;
  border: 1px solid #555;
  color: #d4d4d4;
  font-family: 'IBM Plex Mono', 'Courier New', Courier, monospace;
  font-size: 14px;
  padding: 8px 16px;
  cursor: pointer;
  white-space: nowrap;
  border-radius: 8px;
}

#send-btn:hover { background: #444; }
#send-btn:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.typing-indicator {
  color: #666;
  font-size: 13px;
  padding: 4px 12px;
}

.typing-indicator::after {
  content: '';
  animation: dots 1.5s steps(4, end) infinite;
}

@keyframes dots {
  0%   { content: ''; }
  25%  { content: '.'; }
  50%  { content: '..'; }
  75%  { content: '...'; }
  100% { content: ''; }
}

/* ─── History Sidebar ──────────────────────────────────────────────── */
#history-toggle {
  background: none;
  border: 1px solid #333;
  color: #888;
  font-family: 'IBM Plex Mono', 'Courier New', Courier, monospace;
  font-size: 12px;
  padding: 2px 8px;
  cursor: pointer;
  border-radius: 6px;
}

#history-toggle:hover { color: #d4d4d4; }

#history-panel {
  position: fixed;
  top: 0;
  left: 0;
  width: 280px;
  height: 100vh;
  background: #141414;
  border-right: 1px solid #333;
  z-index: 30;
  display: none;
  flex-direction: column;
}

#history-panel.open {
  display: flex;
}

#history-header {
  padding: 10px 12px;
  border-bottom: 1px solid #333;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 8px;
}

#history-header span {
  font-size: 13px;
  color: #888;
  font-weight: 500;
}

#new-chat-btn {
  background: #1a1a1a;
  border: 1px solid #444;
  color: #7fdbca;
  font-family: 'IBM Plex Mono', 'Courier New', Courier, monospace;
  font-size: 12px;
  padding: 4px 10px;
  cursor: pointer;
  border-radius: 6px;
  white-space: nowrap;
}

#new-chat-btn:hover {
  background: #252525;
  border-color: #7fdbca;
}

#history-list {
  flex: 1;
  overflow-y: auto;
}

.history-item {
  padding: 10px 12px;
  border-bottom: 1px solid #1e1e1e;
  cursor: pointer;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 8px;
}

.history-item:hover {
  background: #1e1e1e;
}

.history-item.active {
  background: #1a2520;
  border-left: 2px solid #7fdbca;
}

.history-item-info {
  flex: 1;
  min-width: 0;
}

.history-item-title {
  font-size: 13px;
  color: #c5c8c6;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.history-item-date {
  font-size: 11px;
  color: #555;
  margin-top: 2px;
}

.history-item-delete {
  background: none;
  border: none;
  color: #555;
  font-size: 16px;
  cursor: pointer;
  padding: 0 4px;
  line-height: 1;
  flex-shrink: 0;
}

.history-item-delete:hover {
  color: #cc6666;
}

.history-empty {
  padding: 20px 12px;
  color: #444;
  font-size: 12px;
  text-align: center;
  font-style: italic;
}

/* Markdown-rendered message content */
.message-body {
  line-height: 1.5;
}
.message-body p { margin: 0 0 0.5em 0; }
.message-body p:last-child { margin-bottom: 0; }
.message-body h1, .message-body h2, .message-body h3 {
  margin: 0.75em 0 0.25em 0;
  font-weight: 600;
  line-height: 1.3;
}
.message-body h1 { font-size: 1.2em; }
.message-body h2 { font-size: 1.05em; }
.message-body h3 { font-size: 1em; }
.message-body h1:first-child, .message-body h2:first-child, .message-body h3:first-child { margin-top: 0; }
.message-body ul, .message-body ol {
  margin: 0.25em 0;
  padding-left: 1.5em;
}
.message-body li { margin: 0.1em 0; }
.message-body li p { margin: 0; }
.message-body code {
  background: #222;
  padding: 0.15em 0.4em;
  border-radius: 4px;
  font-size: 0.92em;
}
.message-body pre {
  background: #111;
  border: 1px solid #2a2a2a;
  border-radius: 6px;
  padding: 10px 12px;
  margin: 0.75em 0;
  overflow-x: auto;
  font-size: 13px;
}
.message-body pre code {
  background: none;
  padding: 0;
}
.message-body blockquote {
  border-left: 3px solid #444;
  margin: 0.75em 0;
  padding-left: 1em;
  color: #999;
}
.message-body a {
  color: #7fdbca;
  text-decoration: none;
}
.message-body a:hover { text-decoration: underline; }
.message-body strong { font-weight: 600; }
.message-body hr {
  border: none;
  border-top: 1px solid #333;
  margin: 1em 0;
}
.message-body table {
  border-collapse: collapse;
  margin: 0.5em 0;
  font-size: 0.9em;
  width: 100%;
}
.message-body th, .message-body td {
  border: 1px solid #333;
  padding: 6px 10px;
  text-align: left;
}
.message-body th {
  background: #1a1a1a;
  font-weight: 600;
  color: #7fdbca;
}
.message-body tr:nth-child(even) {
  background: #111;
}

#history-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0, 0, 0, 0.4);
  z-index: 25;
  display: none;
}

#history-overlay.open {
  display: block;
}
</style>
</head>
<body>

<div id="config-panel">
  <button id="history-toggle">chats</button>
  <div class="config-group">
    <label for="api-provider">Provider:</label>
    <select id="api-provider">
      <option value="">Custom</option>
      <option value="openai">OpenAI</option>
      <option value="anthropic">Anthropic</option>
      <option value="groq">Groq</option>
      <option value="together">Together AI</option>
      <option value="mistral">Mistral</option>
      <option value="openrouter">OpenRouter</option>
    </select>
  </div>
  <div class="config-group">
    <label for="api-base-url">URL:</label>
    <input type="text" id="api-base-url" placeholder="https://api.openai.com/v1">
  </div>
  <div class="config-group">
    <label for="model-name">Model:</label>
    <input type="text" id="model-name" placeholder="gpt-5-2">
  </div>
  <div class="config-group">
    <label for="api-key">Key:</label>
    <input type="password" id="api-key" placeholder="sk-...">
  </div>
  <button id="save-config-btn">Save</button>
  <button id="download-db-btn">Download DB</button>
  <button id="download-sql-btn">Download SQL</button>
  <button id="upload-db-btn">Upload DB</button>
  <input type="file" id="upload-db-input" accept=".db,.sqlite,.sqlite3" style="display:none">
  <button id="reset-db-btn">Reset DB</button>
  <button id="config-toggle">cfg</button>
</div>

<div id="history-overlay"></div>
<div id="history-panel">
  <div id="history-header">
    <span>Conversations</span>
    <button id="new-chat-btn">+ New</button>
  </div>
  <div id="history-list"></div>
</div>

<div id="chat-container"></div>

<div id="input-area">
  <textarea id="user-input" placeholder="Type a message... (Shift+Enter for new line)" autocomplete="off" rows="1"></textarea>
  <button id="send-btn">Send</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.js"></script>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/dompurify@3/dist/purify.min.js"></script>
<script>
(function() {
  'use strict';

  // ─── Constants ───────────────────────────────────────────────────────
  const LS_KEY_DB = 'mealprep_db';
  const LS_KEY_CONFIG = 'mealprep_config';
  const LS_KEY_CHAT = 'mealprep_chat';
  const LS_KEY_CONVERSATIONS = 'mealprep_conversations';

  // ─── Schema ──────────────────────────────────────────────────────────
  const SCHEMA_SQL = `
    CREATE TABLE IF NOT EXISTS recipes (
      id TEXT PRIMARY KEY,
      name TEXT NOT NULL,
      type TEXT CHECK(type IN ('main','side')),
      servings INTEGER,
      yield_amount REAL,
      yield_unit TEXT,
      frozen_shelf_life_days INTEGER,
      fridge_shelf_life_days INTEGER
    );

    CREATE TABLE IF NOT EXISTS ingredients (
      id TEXT PRIMARY KEY,
      name TEXT NOT NULL,
      quantity TEXT,
      unit TEXT,
      type TEXT CHECK(type IN ('Meat','Poultry','Fish','Vegetables','Fruits','Dairy','Deli/Cheese','Pantry/Canned','Condiments','Other'))
    );

    CREATE TABLE IF NOT EXISTS steps (
      id TEXT PRIMARY KEY,
      recipe_id TEXT NOT NULL,
      description TEXT NOT NULL,
      phase TEXT CHECK(phase IN ('meal-prep','day-of-eating')),
      order_num INTEGER,
      duration_minutes INTEGER,
      FOREIGN KEY (recipe_id) REFERENCES recipes(id)
    );

    CREATE TABLE IF NOT EXISTS step_dependencies (
      step_id TEXT NOT NULL,
      depends_on_step_id TEXT NOT NULL,
      PRIMARY KEY (step_id, depends_on_step_id),
      FOREIGN KEY (step_id) REFERENCES steps(id),
      FOREIGN KEY (depends_on_step_id) REFERENCES steps(id)
    );

    CREATE TABLE IF NOT EXISTS step_ingredients (
      step_id TEXT NOT NULL,
      ingredient_id TEXT NOT NULL,
      PRIMARY KEY (step_id, ingredient_id),
      FOREIGN KEY (step_id) REFERENCES steps(id),
      FOREIGN KEY (ingredient_id) REFERENCES ingredients(id)
    );

    CREATE TABLE IF NOT EXISTS resources (
      id TEXT PRIMARY KEY,
      name TEXT NOT NULL,
      type TEXT CHECK(type IN ('oven','pan','pot','stove'))
    );

    CREATE TABLE IF NOT EXISTS step_resource_usage (
      step_id TEXT NOT NULL,
      resource_id TEXT NOT NULL,
      temperature_celsius INTEGER,
      notes TEXT,
      PRIMARY KEY (step_id, resource_id),
      FOREIGN KEY (step_id) REFERENCES steps(id),
      FOREIGN KEY (resource_id) REFERENCES resources(id)
    );

    CREATE TABLE IF NOT EXISTS meal_prep_sessions (
      id TEXT PRIMARY KEY,
      date TEXT NOT NULL,
      notes TEXT
    );

    CREATE TABLE IF NOT EXISTS batches (
      id TEXT PRIMARY KEY,
      recipe_id TEXT NOT NULL,
      session_id TEXT NOT NULL,
      servings_produced INTEGER NOT NULL,
      prep_date TEXT NOT NULL,
      FOREIGN KEY (recipe_id) REFERENCES recipes(id),
      FOREIGN KEY (session_id) REFERENCES meal_prep_sessions(id)
    );

    CREATE TABLE IF NOT EXISTS consumptions (
      id TEXT PRIMARY KEY,
      batch_id TEXT NOT NULL,
      servings_consumed INTEGER NOT NULL,
      consumption_date TEXT NOT NULL,
      FOREIGN KEY (batch_id) REFERENCES batches(id)
    );

    CREATE TABLE IF NOT EXISTS weeks (
      id TEXT PRIMARY KEY,
      start_date TEXT NOT NULL,
      notes TEXT
    );

    CREATE TABLE IF NOT EXISTS meal_plan_slots (
      id TEXT PRIMARY KEY,
      week_id TEXT NOT NULL,
      day_of_week TEXT CHECK(day_of_week IN ('Monday','Tuesday','Wednesday','Thursday','Friday','Saturday','Sunday')),
      meal_type TEXT CHECK(meal_type IN ('lunch','dinner')),
      FOREIGN KEY (week_id) REFERENCES weeks(id)
    );

    CREATE TABLE IF NOT EXISTS meal_plan_slot_recipes (
      slot_id TEXT NOT NULL,
      recipe_id TEXT NOT NULL,
      PRIMARY KEY (slot_id, recipe_id),
      FOREIGN KEY (slot_id) REFERENCES meal_plan_slots(id),
      FOREIGN KEY (recipe_id) REFERENCES recipes(id)
    );
  `;

  // ─── System Prompt ───────────────────────────────────────────────────
  const SYSTEM_PROMPT = `You are a meal prep assistant with SQLite database access via the execute_sql tool.

By default, use Argentine Spanish for all text, both in chat and in the database, unless the user uses a different language.

SCHEMA:
recipes (id TEXT PK, name, type ['main'|'side'], servings INT, yield_amount REAL, yield_unit, frozen_shelf_life_days INT, fridge_shelf_life_days INT)
ingredients (id TEXT PK, name, quantity, unit, type ['Meat'|'Poultry'|'Fish'|'Vegetables'|'Fruits'|'Dairy'|'Deli/Cheese'|'Pantry/Canned'|'Condiments'|'Other'])
steps (id TEXT PK, recipe_id FK, description, phase ['meal-prep'|'day-of-eating'], order_num INT, duration_minutes INT)
step_dependencies (step_id FK, depends_on_step_id FK) — composite PK
step_ingredients (step_id FK, ingredient_id FK) — composite PK
resources (id TEXT PK, name, type ['oven'|'pan'|'pot'|'stove'])
step_resource_usage (step_id FK, resource_id FK, temperature_celsius INT, notes) — composite PK
meal_prep_sessions (id TEXT PK, date, notes)
batches (id TEXT PK, recipe_id FK, session_id FK, servings_produced INT, prep_date)
consumptions (id TEXT PK, batch_id FK, servings_consumed INT, consumption_date)
weeks (id TEXT PK, start_date, notes)
meal_plan_slots (id TEXT PK, week_id FK, day_of_week ['Monday'..'Sunday'], meal_type ['lunch'|'dinner'])
meal_plan_slot_recipes (slot_id FK, recipe_id FK) — composite PK, allows multiple recipes per slot

CONVENTIONS:
- IDs: prefix_N format (recipe_1, batch_12). Query existing IDs to find next number.
- Dates: ISO 8601 (YYYY-MM-DD)
- Stock calculation: servings_produced - SUM(servings_consumed)

KEY BEHAVIORS:
- Use markdown tables for lists, meal plans (week grid), inventory, shopping lists
- If shelf life not provided: estimate based on food type and confirm with user before saving
- When adding recipe steps: infer dependencies from ingredient/output flow, but avoid over-serializing. Confirm your reasoning. Independent prep steps (chopping, etc.) can be parallel.
- Ask for clarification when genuinely ambiguous (multiple batches to choose from, vague quantities). Don't ask for things you can reasonably infer.
- Proactively warn about items expiring within 2 days when showing inventory.`;

  // ─── State ───────────────────────────────────────────────────────────
  let db = null;
  let conversationHistory = [];
  let conversations = [];
  let activeConversationId = null;

  // ─── DOM Elements ────────────────────────────────────────────────────
  const chatContainer = document.getElementById('chat-container');
  const userInput = document.getElementById('user-input');
  const sendBtn = document.getElementById('send-btn');
  const configPanel = document.getElementById('config-panel');
  const configToggle = document.getElementById('config-toggle');
  const apiBaseUrlInput = document.getElementById('api-base-url');
  const modelNameInput = document.getElementById('model-name');
  const apiKeyInput = document.getElementById('api-key');
  const apiProviderSelect = document.getElementById('api-provider');
  const saveConfigBtn = document.getElementById('save-config-btn');
  const downloadDbBtn = document.getElementById('download-db-btn');
  const downloadSqlBtn = document.getElementById('download-sql-btn');
  const uploadDbBtn = document.getElementById('upload-db-btn');
  const uploadDbInput = document.getElementById('upload-db-input');
  const resetDbBtn = document.getElementById('reset-db-btn');
  const historyToggle = document.getElementById('history-toggle');
  const historyPanel = document.getElementById('history-panel');
  const historyOverlay = document.getElementById('history-overlay');
  const newChatBtn = document.getElementById('new-chat-btn');
  const historyList = document.getElementById('history-list');

  const API_PROVIDERS = {
    openai:     { url: 'https://api.openai.com/v1',            model: 'gpt-5-2' },
    anthropic:  { url: 'https://api.anthropic.com/v1',          model: 'claude-sonnet-4-5-20250929' },
    groq:       { url: 'https://api.groq.com/openai/v1',       model: 'llama-3.3-70b-versatile' },
    together:   { url: 'https://api.together.xyz/v1',           model: 'meta-llama/Meta-Llama-3.1-70B-Instruct-Turbo' },
    mistral:    { url: 'https://api.mistral.ai/v1',             model: 'mistral-large-latest' },
    openrouter: { url: 'https://openrouter.ai/api/v1',          model: 'openai/gpt-5-2' },
  };

  // ─── Database ────────────────────────────────────────────────────────
  async function initDatabase() {
    const SQL = await initSqlJs({
      locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${file}`
    });

    const savedDb = localStorage.getItem(LS_KEY_DB);
    if (savedDb) {
      try {
        const buf = Uint8Array.from(atob(savedDb), c => c.charCodeAt(0));
        db = new SQL.Database(buf);
      } catch (e) {
        console.error('Failed to load saved database, creating new one:', e);
        db = new SQL.Database();
      }
    } else {
      db = new SQL.Database();
    }

    // Enable foreign keys and ensure schema exists
    db.run('PRAGMA foreign_keys = ON;');
    db.run(SCHEMA_SQL);
    migrateDatabase();
    saveDatabase();
  }

  function migrateDatabase() {
    // Migration: add 'type' column to recipes if missing
    const recipeCols = db.exec("PRAGMA table_info(recipes)");
    if (recipeCols.length > 0) {
      const colNames = recipeCols[0].values.map(r => r[1]);
      if (!colNames.includes('type')) {
        db.run("ALTER TABLE recipes ADD COLUMN type TEXT CHECK(type IN ('main','side'))");
      }
    }

    // Migration: move recipe_id from meal_plan_slots into meal_plan_slot_recipes
    const slotCols = db.exec("PRAGMA table_info(meal_plan_slots)");
    if (slotCols.length > 0) {
      const colNames = slotCols[0].values.map(r => r[1]);
      if (colNames.includes('recipe_id')) {
        // Ensure junction table exists
        db.run(`CREATE TABLE IF NOT EXISTS meal_plan_slot_recipes (
          slot_id TEXT NOT NULL,
          recipe_id TEXT NOT NULL,
          PRIMARY KEY (slot_id, recipe_id),
          FOREIGN KEY (slot_id) REFERENCES meal_plan_slots(id),
          FOREIGN KEY (recipe_id) REFERENCES recipes(id)
        )`);
        // Migrate existing assignments
        db.run(`INSERT OR IGNORE INTO meal_plan_slot_recipes (slot_id, recipe_id)
          SELECT id, recipe_id FROM meal_plan_slots WHERE recipe_id IS NOT NULL`);
        // Drop recipe_id column
        db.run("ALTER TABLE meal_plan_slots DROP COLUMN recipe_id");
      }
    }

    // Migration: ingredient categories Spanish → English
    const ingredientsSchema = db.exec("SELECT sql FROM sqlite_master WHERE type='table' AND name='ingredients'");
    if (ingredientsSchema.length > 0 && ingredientsSchema[0].values.length > 0) {
      const tableSql = ingredientsSchema[0].values[0][0] || '';
      if (tableSql.includes("'Carne'")) {
        db.run('PRAGMA foreign_keys = OFF');
        db.run(`CREATE TABLE ingredients_new (
          id TEXT PRIMARY KEY,
          name TEXT NOT NULL,
          quantity TEXT,
          unit TEXT,
          type TEXT CHECK(type IN ('Meat','Poultry','Fish','Vegetables','Fruits','Dairy','Deli/Cheese','Pantry/Canned','Condiments','Other'))
        )`);
        db.run(`INSERT INTO ingredients_new (id, name, quantity, unit, type)
          SELECT id, name, quantity, unit,
            CASE type
              WHEN 'Carne' THEN 'Meat'
              WHEN 'Pollo' THEN 'Poultry'
              WHEN 'Pescado' THEN 'Fish'
              WHEN 'Verduras' THEN 'Vegetables'
              WHEN 'Frutas' THEN 'Fruits'
              WHEN 'Lacteos' THEN 'Dairy'
              WHEN 'Fiambres-Quesos' THEN 'Deli/Cheese'
              WHEN 'Secos-Enlatados' THEN 'Pantry/Canned'
              WHEN 'Condimentos' THEN 'Condiments'
              WHEN 'Otros' THEN 'Other'
              ELSE type
            END
          FROM ingredients`);
        db.run('DROP TABLE ingredients');
        db.run('ALTER TABLE ingredients_new RENAME TO ingredients');
        db.run('PRAGMA foreign_keys = ON');
      }
    }
  }

  function saveDatabase() {
    if (!db) return;
    try {
      const data = db.export();
      let binary = '';
      const chunkSize = 8192;
      for (let i = 0; i < data.length; i += chunkSize) {
        binary += String.fromCharCode.apply(null, data.subarray(i, i + chunkSize));
      }
      const b64 = btoa(binary);
      localStorage.setItem(LS_KEY_DB, b64);
    } catch (e) {
      console.error('Failed to save database:', e);
    }
  }

  function downloadDatabase() {
    if (!db) return;
    try {
      const data = db.export();
      const blob = new Blob([data], { type: 'application/x-sqlite3' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'mealprep.db';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      addMessage('system', 'Database downloaded.');
    } catch (e) {
      console.error('Failed to download database:', e);
      addMessage('error', 'Failed to download database: ' + e.message);
    }
  }

  function escapeSqlLiteral(val) {
    if (val === null) return 'NULL';
    if (typeof val === 'number') return String(val);
    return "'" + String(val).replace(/'/g, "''") + "'";
  }

  function downloadSqlDump() {
    if (!db) return;
    try {
      const tablesResult = db.exec(
        "SELECT name, sql FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%' ORDER BY name"
      );
      if (!tablesResult.length || !tablesResult[0].values.length) {
        addMessage('system', 'Database is empty; nothing to dump.');
        return;
      }
      const lines = ['-- Meal Prep DB SQL dump', '-- Generated by meal-prep app', ''];
      const nameIdx = tablesResult[0].columns.indexOf('name');
      const sqlIdx = tablesResult[0].columns.indexOf('sql');
      for (const row of tablesResult[0].values) {
        const tableName = row[nameIdx];
        const createSql = row[sqlIdx];
        if (!createSql) continue;
        lines.push('-- Table: ' + tableName);
        lines.push(createSql + ';');
        lines.push('');
        const dataResult = db.exec('SELECT * FROM "' + tableName.replace(/"/g, '""') + '"');
        if (dataResult.length && dataResult[0].values.length) {
          const cols = dataResult[0].columns;
          const colList = cols.map(c => '"' + c.replace(/"/g, '""') + '"').join(', ');
          for (const vrow of dataResult[0].values) {
            const vals = vrow.map(escapeSqlLiteral).join(', ');
            lines.push('INSERT INTO "' + tableName.replace(/"/g, '""') + '" (' + colList + ') VALUES (' + vals + ');');
          }
          lines.push('');
        }
      }
      const sql = lines.join('\n');
      const blob = new Blob([sql], { type: 'text/plain;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'mealprep.sql';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      addMessage('system', 'SQL dump downloaded.');
    } catch (e) {
      console.error('Failed to download SQL dump:', e);
      addMessage('error', 'Failed to download SQL dump: ' + e.message);
    }
  }

  async function uploadDatabase(file) {
    if (!file) return;
    try {
      const SQL = await initSqlJs({
        locateFile: f => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${f}`
      });
      const buffer = await file.arrayBuffer();
      const newDb = new SQL.Database(new Uint8Array(buffer));
      // Validate by running a simple query
      newDb.exec('SELECT count(*) FROM sqlite_master');
      db = newDb;
      db.run('PRAGMA foreign_keys = ON;');
      db.run(SCHEMA_SQL);
      migrateDatabase();
      saveDatabase();
      addMessage('system', 'Database uploaded and loaded successfully.');
    } catch (e) {
      console.error('Failed to upload database:', e);
      addMessage('error', 'Failed to upload database: ' + e.message);
    }
  }

  function executeSQL(query) {
    if (!db) return { error: 'Database not initialized' };
    try {
      // Split on semicolons but respect quoted strings
      const stmts = splitStatements(query);
      const allResults = [];

      for (const stmt of stmts) {
        const trimmed = stmt.trim();
        if (!trimmed) continue;

        const upper = trimmed.toUpperCase();
        if (upper.startsWith('SELECT') || upper.startsWith('PRAGMA') || upper.startsWith('WITH') || upper.startsWith('EXPLAIN')) {
          const res = db.exec(trimmed);
          if (res.length > 0) {
            const rows = res[0].values.map(row => {
              const obj = {};
              res[0].columns.forEach((col, i) => { obj[col] = row[i]; });
              return obj;
            });
            allResults.push({ columns: res[0].columns, rows: rows, rowCount: rows.length });
          } else {
            allResults.push({ columns: [], rows: [], rowCount: 0 });
          }
        } else {
          db.run(trimmed);
          const changes = db.getRowsModified();
          allResults.push({ rowsAffected: changes });
        }
      }

      saveDatabase();

      if (allResults.length === 1) return allResults[0];
      return allResults;
    } catch (e) {
      return { error: e.message };
    }
  }

  function splitStatements(sql) {
    const stmts = [];
    let current = '';
    let inSingle = false;
    let inDouble = false;

    for (let i = 0; i < sql.length; i++) {
      const ch = sql[i];
      if (ch === "'" && !inDouble) {
        inSingle = !inSingle;
      } else if (ch === '"' && !inSingle) {
        inDouble = !inDouble;
      } else if (ch === ';' && !inSingle && !inDouble) {
        stmts.push(current);
        current = '';
        continue;
      }
      current += ch;
    }
    if (current.trim()) stmts.push(current);
    return stmts;
  }

  // ─── Configuration ──────────────────────────────────────────────────
  function loadConfig() {
    try {
      const saved = localStorage.getItem(LS_KEY_CONFIG);
      if (saved) {
        const config = JSON.parse(saved);
        apiBaseUrlInput.value = config.baseUrl || '';
        modelNameInput.value = config.model || '';
        apiKeyInput.value = config.apiKey || '';
        apiProviderSelect.value = config.provider || '';
      }
    } catch (e) {
      console.error('Failed to load config:', e);
    }
  }

  function saveConfig() {
    const config = {
      baseUrl: apiBaseUrlInput.value.trim(),
      model: modelNameInput.value.trim(),
      apiKey: apiKeyInput.value.trim(),
      provider: apiProviderSelect.value
    };
    localStorage.setItem(LS_KEY_CONFIG, JSON.stringify(config));
    addMessage('system', 'Configuration saved.');
  }

  function getConfig() {
    return {
      baseUrl: apiBaseUrlInput.value.trim(),
      model: modelNameInput.value.trim(),
      apiKey: apiKeyInput.value.trim()
    };
  }

  // ─── Chat UI ─────────────────────────────────────────────────────────
  function renderMarkdown(text) {
    if (typeof marked === 'undefined' || typeof DOMPurify === 'undefined') {
      const span = document.createElement('span');
      span.textContent = text;
      return span;
    }
    try {
      const rawHtml = marked.parse(text, { gfm: true, breaks: true });
      const safeHtml = DOMPurify.sanitize(rawHtml, {
        ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'a', 'ul', 'ol', 'li', 'h1', 'h2', 'h3', 'h4', 'code', 'pre', 'blockquote', 'hr', 'table', 'thead', 'tbody', 'tr', 'th', 'td'],
        ALLOWED_ATTR: ['href', 'target']
      });
      const wrap = document.createElement('div');
      wrap.className = 'message-body';
      wrap.innerHTML = safeHtml;
      return wrap;
    } catch (e) {
      const span = document.createElement('span');
      span.className = 'message-body';
      span.style.whiteSpace = 'pre-wrap';
      span.textContent = text;
      return span;
    }
  }

  function addMessage(role, content) {
    const div = document.createElement('div');
    div.className = `message message-${role}`;
    if (role === 'assistant' && content) {
      div.appendChild(renderMarkdown(content));
    } else {
      // User/system messages: plain text, inline display
      const span = document.createElement('span');
      span.style.whiteSpace = 'pre-wrap';
      span.textContent = content;
      div.appendChild(span);
    }
    chatContainer.appendChild(div);
    chatContainer.scrollTop = chatContainer.scrollHeight;
    return div;
  }

  function addTypingIndicator() {
    const div = document.createElement('div');
    div.className = 'typing-indicator';
    div.textContent = 'Thinking';
    div.id = 'typing';
    chatContainer.appendChild(div);
    chatContainer.scrollTop = chatContainer.scrollHeight;
    return div;
  }

  function removeTypingIndicator() {
    const el = document.getElementById('typing');
    if (el) el.remove();
  }

  // ─── Conversation Management ────────────────────────────────────────
  function generateConversationId() {
    return 'conv_' + Date.now() + '_' + Math.random().toString(36).substr(2, 6);
  }

  function getConversationTitle(messages) {
    const firstUserMsg = messages.find(m => m.role === 'user');
    if (firstUserMsg) {
      const text = firstUserMsg.content.trim();
      return text.length > 50 ? text.substring(0, 50) + '...' : text;
    }
    return 'New conversation';
  }

  function getTextMessages() {
    return conversationHistory.filter(m =>
      (m.role === 'user' || m.role === 'assistant') && typeof m.content === 'string'
    );
  }

  function loadConversations() {
    try {
      const saved = localStorage.getItem(LS_KEY_CONVERSATIONS);
      if (saved) {
        conversations = JSON.parse(saved);
      }

      // Migrate from old single-chat format
      if (conversations.length === 0) {
        const oldChat = localStorage.getItem(LS_KEY_CHAT);
        if (oldChat) {
          const messages = JSON.parse(oldChat);
          if (messages.length > 0) {
            const conv = {
              id: generateConversationId(),
              title: getConversationTitle(messages),
              createdAt: new Date().toISOString(),
              messages: messages
            };
            conversations.push(conv);
            activeConversationId = conv.id;
            saveConversations();
          }
          localStorage.removeItem(LS_KEY_CHAT);
        }
      }
    } catch (e) {
      console.error('Failed to load conversations:', e);
      conversations = [];
    }
  }

  function saveConversations() {
    try {
      localStorage.setItem(LS_KEY_CONVERSATIONS, JSON.stringify(conversations));
    } catch (e) {
      console.error('Failed to save conversations:', e);
    }
  }

  function saveCurrentConversation() {
    const textMessages = getTextMessages();
    if (textMessages.length === 0) return;

    if (activeConversationId) {
      const idx = conversations.findIndex(c => c.id === activeConversationId);
      if (idx >= 0) {
        conversations[idx].messages = textMessages;
        conversations[idx].title = getConversationTitle(textMessages);
      } else {
        conversations.unshift({
          id: activeConversationId,
          title: getConversationTitle(textMessages),
          createdAt: new Date().toISOString(),
          messages: textMessages
        });
      }
    } else {
      activeConversationId = generateConversationId();
      conversations.unshift({
        id: activeConversationId,
        title: getConversationTitle(textMessages),
        createdAt: new Date().toISOString(),
        messages: textMessages
      });
    }
    saveConversations();
  }

  function saveChatHistory() {
    saveCurrentConversation();
    renderConversationList();
  }

  function loadChatHistory() {
    loadConversations();

    if (activeConversationId) {
      const conv = conversations.find(c => c.id === activeConversationId);
      if (conv) {
        conversationHistory = [...conv.messages];
        renderMessages();
      }
    } else if (conversations.length > 0) {
      // Load most recent conversation
      activeConversationId = conversations[0].id;
      conversationHistory = [...conversations[0].messages];
      renderMessages();
    }

    renderConversationList();
  }

  function renderMessages() {
    for (const msg of conversationHistory) {
      if (msg.role === 'user') {
        addMessage('user', msg.content);
      } else if (msg.role === 'assistant' && typeof msg.content === 'string') {
        addMessage('assistant', msg.content);
      }
    }
  }

  function startNewChat() {
    saveCurrentConversation();

    conversationHistory = [];
    activeConversationId = generateConversationId();

    chatContainer.innerHTML = '';
    addMessage('system', 'New conversation started.');

    renderConversationList();
    closeHistoryPanel();
    userInput.focus();
  }

  function switchToConversation(id) {
    if (id === activeConversationId) {
      closeHistoryPanel();
      return;
    }

    saveCurrentConversation();

    const conv = conversations.find(c => c.id === id);
    if (!conv) return;

    activeConversationId = id;
    conversationHistory = [...conv.messages];

    chatContainer.innerHTML = '';
    renderMessages();

    renderConversationList();
    closeHistoryPanel();
    userInput.focus();
  }

  function deleteConversation(id, event) {
    event.stopPropagation();

    const idx = conversations.findIndex(c => c.id === id);
    if (idx < 0) return;

    conversations.splice(idx, 1);
    saveConversations();

    if (id === activeConversationId) {
      conversationHistory = [];
      activeConversationId = generateConversationId();
      chatContainer.innerHTML = '';
      addMessage('system', 'Meal Prep Chat ready. Configure your API settings above, then start chatting.');
    }

    renderConversationList();
  }

  function renderConversationList() {
    historyList.innerHTML = '';

    for (const conv of conversations) {
      const item = document.createElement('div');
      item.className = 'history-item' + (conv.id === activeConversationId ? ' active' : '');

      const info = document.createElement('div');
      info.className = 'history-item-info';

      const title = document.createElement('div');
      title.className = 'history-item-title';
      title.textContent = conv.title;

      const date = document.createElement('div');
      date.className = 'history-item-date';
      date.textContent = new Date(conv.createdAt).toLocaleDateString();

      info.appendChild(title);
      info.appendChild(date);

      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'history-item-delete';
      deleteBtn.textContent = '\u00d7';
      deleteBtn.addEventListener('click', (e) => deleteConversation(conv.id, e));

      item.appendChild(info);
      item.appendChild(deleteBtn);
      item.addEventListener('click', () => switchToConversation(conv.id));

      historyList.appendChild(item);
    }

    if (conversations.length === 0) {
      const empty = document.createElement('div');
      empty.className = 'history-empty';
      empty.textContent = 'No conversations yet';
      historyList.appendChild(empty);
    }
  }

  function toggleHistoryPanel() {
    const isOpen = historyPanel.classList.contains('open');
    if (isOpen) {
      closeHistoryPanel();
    } else {
      historyPanel.classList.add('open');
      historyOverlay.classList.add('open');
    }
  }

  function closeHistoryPanel() {
    historyPanel.classList.remove('open');
    historyOverlay.classList.remove('open');
  }

  // ─── LLM Integration ────────────────────────────────────────────────
  const TOOL_DEFINITION = {
    type: 'function',
    function: {
      name: 'execute_sql',
      description: 'Execute one or more SQL statements against the SQLite database. Supports SELECT, INSERT, UPDATE, DELETE, and other SQL operations. Multiple statements can be separated by semicolons.',
      parameters: {
        type: 'object',
        properties: {
          query: {
            type: 'string',
            description: 'The SQL query or queries to execute. Multiple statements can be separated by semicolons.'
          }
        },
        required: ['query']
      }
    }
  };

  async function callLLM(messages) {
    const config = getConfig();

    if (!config.baseUrl || !config.model || !config.apiKey) {
      throw new Error('Please configure API URL, model, and API key in the settings panel.');
    }

    let baseUrl = config.baseUrl.replace(/\/+$/, '');
    // Ensure we have the chat completions endpoint
    const endpoint = `${baseUrl}/chat/completions`;

    const body = {
      model: config.model,
      messages: messages,
      tools: [TOOL_DEFINITION],
      tool_choice: 'auto'
    };

    const headers = {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${config.apiKey}`
    };
    // Anthropic requires this header for CORS / direct browser access (BYOK use case).
    if (baseUrl.includes('api.anthropic.com')) {
      headers['anthropic-dangerous-direct-browser-access'] = 'true';
    }

    const response = await fetch(endpoint, {
      method: 'POST',
      headers,
      body: JSON.stringify(body)
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`API error (${response.status}): ${errorText}`);
    }

    return await response.json();
  }

  async function handleUserMessage(text) {
    if (!text.trim()) return;

    // Add user message to UI and history
    addMessage('user', text);
    conversationHistory.push({ role: 'user', content: text });
    saveChatHistory();

    sendBtn.disabled = true;
    userInput.disabled = true;

    const typingEl = addTypingIndicator();

    try {
      // Build messages array with system prompt + current datetime
      const now = new Date();
      const currentDate = now.toISOString().split('T')[0];
      const currentTime = now.toTimeString().split(' ')[0].slice(0, 5);
      const dayOfWeek = now.toLocaleDateString('en-US', { weekday: 'long' });
      const systemPromptWithDate = SYSTEM_PROMPT + `\n\nCURRENT: ${dayOfWeek}, ${currentDate} ${currentTime}`;
      
      let messages = [
        { role: 'system', content: systemPromptWithDate },
        ...conversationHistory
      ];

      // Iterative tool-call loop
      let maxIterations = 20;
      let iteration = 0;

      while (iteration < maxIterations) {
        iteration++;

        const response = await callLLM(messages);
        const choice = response.choices && response.choices[0];

        if (!choice) {
          throw new Error('No response from LLM');
        }

        const message = choice.message;

        // Check if there are tool calls
        if (message.tool_calls && message.tool_calls.length > 0) {
          // Add assistant message with tool calls to history
          conversationHistory.push({
            role: 'assistant',
            content: message.content || null,
            tool_calls: message.tool_calls
          });

          // If there's text content alongside tool calls, display it
          if (message.content) {
            removeTypingIndicator();
            addMessage('assistant', message.content);
            addTypingIndicator();
          }

          // Update messages for next iteration
          messages.push({
            role: 'assistant',
            content: message.content || null,
            tool_calls: message.tool_calls
          });

          // Process each tool call
          for (const toolCall of message.tool_calls) {
            if (toolCall.function.name === 'execute_sql') {
              let args;
              try {
                args = JSON.parse(toolCall.function.arguments);
              } catch (e) {
                args = { query: toolCall.function.arguments };
              }

              const result = executeSQL(args.query);
              const resultStr = JSON.stringify(result, null, 2);

              // Add tool result to history and messages
              const toolResult = {
                role: 'tool',
                tool_call_id: toolCall.id,
                content: resultStr
              };
              conversationHistory.push(toolResult);
              messages.push(toolResult);
            }
          }
        } else {
          // No tool calls - final response
          const assistantText = message.content || '(No response)';
          conversationHistory.push({ role: 'assistant', content: assistantText });
          removeTypingIndicator();
          addMessage('assistant', assistantText);
          saveChatHistory();
          break;
        }
      }

      if (iteration >= maxIterations) {
        removeTypingIndicator();
        addMessage('error', 'Maximum tool call iterations reached.');
      }

    } catch (e) {
      removeTypingIndicator();
      addMessage('error', `Error: ${e.message}`);
    } finally {
      sendBtn.disabled = false;
      userInput.disabled = false;
      userInput.focus();
    }
  }

  // ─── Event Listeners ────────────────────────────────────────────────
  sendBtn.addEventListener('click', () => {
    handleUserMessage(userInput.value);
    userInput.value = '';
    userInput.style.height = 'auto';
  });

  userInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendBtn.click();
    }
  });

  userInput.addEventListener('input', () => {
    userInput.style.overflow = 'hidden';
    userInput.style.height = 'auto';
    const h = Math.min(userInput.scrollHeight, 120);
    userInput.style.height = h + 'px';
    userInput.style.overflow = '';
  });

  apiProviderSelect.addEventListener('change', () => {
    const provider = API_PROVIDERS[apiProviderSelect.value];
    if (provider) {
      apiBaseUrlInput.value = provider.url;
      modelNameInput.value = provider.model;
    }
  });

  saveConfigBtn.addEventListener('click', saveConfig);

  downloadDbBtn.addEventListener('click', downloadDatabase);
  downloadSqlBtn.addEventListener('click', downloadSqlDump);

  uploadDbBtn.addEventListener('click', () => {
    uploadDbInput.click();
  });

  uploadDbInput.addEventListener('change', () => {
    const file = uploadDbInput.files[0];
    if (file) {
      if (confirm('This will replace the current database. Are you sure?')) {
        uploadDatabase(file);
      }
      uploadDbInput.value = '';
    }
  });

  resetDbBtn.addEventListener('click', () => {
    if (confirm('This will delete all data and conversations. Are you sure?')) {
      localStorage.removeItem(LS_KEY_DB);
      localStorage.removeItem(LS_KEY_CHAT);
      localStorage.removeItem(LS_KEY_CONVERSATIONS);
      conversationHistory = [];
      conversations = [];
      activeConversationId = generateConversationId();
      chatContainer.innerHTML = '';
      renderConversationList();
      initDatabase().then(() => {
        addMessage('system', 'Database reset. All data cleared.');
      });
    }
  });

  configToggle.addEventListener('click', () => {
    configPanel.style.display = configPanel.style.display === 'none' ? 'flex' : 'none';
  });

  historyToggle.addEventListener('click', toggleHistoryPanel);
  historyOverlay.addEventListener('click', closeHistoryPanel);
  newChatBtn.addEventListener('click', startNewChat);

  // ─── Initialize ──────────────────────────────────────────────────────
  loadConfig();
  initDatabase().then(() => {
    loadChatHistory();
    if (conversationHistory.length === 0) {
      activeConversationId = generateConversationId();
      addMessage('system', 'Meal Prep Chat ready. Configure your API settings above, then start chatting.');
    }
    userInput.focus();
  });

})();
</script>
</body>
</html>
